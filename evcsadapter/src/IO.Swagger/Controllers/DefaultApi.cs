/*
 * Charging Station Monitoring API
 *
 * Single endpoint to receive bulk updates from a Charging Station Management System (CSMS). The server is expected to update its internal database based on the differential changes in the data and respond with a list of load curves (one per charging station). A call to this endpoint is made as soon as new data is available or if not data is available on a set interval. 
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;
using Swashbuckle.AspNetCore.Annotations;
using Swashbuckle.AspNetCore.SwaggerGen;
using Newtonsoft.Json;
using System.ComponentModel.DataAnnotations;
using IO.Swagger.Attributes;
using IO.Swagger.Security;
using Microsoft.AspNetCore.Authorization;
using IO.Swagger.Models;
using Newtonsoft.Json.Linq;
using System.Net;
using System.Threading.Tasks;
using Azure.DigitalTwins.Core;
using Azure;
using IoT.Services;
using Microsoft.Extensions.Logging;
using Microsoft.VisualBasic;
using System.ComponentModel;

namespace IO.Swagger.Controllers
{
    /// <summary>
    /// API server for the EV CS CHESS adapter
    /// </summary>
    [ApiController]
    public class DefaultApiController : Controller
    {



        protected static List<CHESS> assets;

        protected static String authToken = "";
        private readonly ILogger<DefaultApiController> _logger;

        // The main CHESS data structure
        public class CHESS
        {

            public String identifier { get; set; }
            public String location { get; set; }
            public String id { get; set; }
            public String currentStatus { get; set; }
            public ChessStatus[] status { get; set; }
            public ChessStatus[] limits { get; set; }


        }


        public class Token
        {
            public String sub { get; set; }
            public String aut { get; set; }
            public String aud { get; set; }
            public String nbf { get; set; }
            public String azp { get; set; }
            public String scope { get; set; }
            public String iss { get; set; }
            public String exp { get; set; }
            public String iat { get; set; }
            public String jti { get; set; }
            public String location { get; set; }
            public String uri { get; set; }

            public Token() { }
        }


        public DefaultApiController(ILogger<DefaultApiController> logger)
        {
            _logger = logger;
            if (assets == null)
                assets = new List<CHESS>();
        }

        // check for the activation of a chess status
        private Boolean getStatus(ChessStatus status)
        {
            DateTime starttime;
            DateTime endtime;

            if (status.recurrence.ToLower().Equals("daily") ||
                (status.recurrence.ToLower().Equals("weekdays") && ((DateTime.Today.DayOfWeek != DayOfWeek.Saturday) && (DateTime.Today.DayOfWeek != DayOfWeek.Sunday))) ||
                (status.recurrence.ToLower().Equals("weekends") && ((DateTime.Today.DayOfWeek == DayOfWeek.Saturday) || (DateTime.Today.DayOfWeek == DayOfWeek.Sunday))))
            {

                return true;


            }

            return false;
        }

        //Function to decode JWT token
        private Token decodeToken(String token)
        {
            String str = token.Substring(token.IndexOf(".") + 1, token.LastIndexOf(".") - token.IndexOf(".") - 1);
            if (str.Length % 4 != 0)
                str += new String('=', 4 - str.Length % 4);

            byte[] data = Convert.FromBase64String(str);
            string decodedString = System.Text.Encoding.UTF8.GetString(data);
            Token jwt = JsonConvert.DeserializeObject<Token>(decodedString);


            return jwt;
        }

        //Get the subject attributes for a twin from the ADT model
        private String getSubjectAttribute(IoT.Services.Chess twin)
        {
            String query = "SELECT DT.$dtId FROM DIGITALTWINS twin JOIN DT RELATED twin.targetSubjectAttributes WHERE twin.$dtId = '" + twin.Id + "AccessControlPermissions'";

            // get the permissions from subject attriubtes for the submodel
            Pageable<BasicDigitalTwin> attributeResponse = Program.dtClient.Query<BasicDigitalTwin>(query);
            String subjectAttribute = "";
            if (attributeResponse != null)
            {

                foreach (BasicDigitalTwin attribute in attributeResponse)
                {
                    subjectAttribute += " " + attribute.Id;
                }


            }
            else subjectAttribute = "default";
            return subjectAttribute;
        }

        /// <summary>
        /// The controller for handling the initialisation of CHESS adapter
        /// </summary>
        /// 
        /// POST - Setup CHESS assets with this adapter

        [HttpPost]
        [Consumes("application/json")]
        [Produces("text/plain")]
        [Route("/init")]
        public IActionResult Init([Required][FromBody] CHESS body, [FromHeader] String Authorization)
        {

            if (body == null)
            {
                return Json(assets);
            }

            // store the token for later use to call APIs
            if (Authorization != null)
                authToken = Authorization;

            Console.WriteLine("Body " + Newtonsoft.Json.JsonConvert.SerializeObject(body));

            assets.Add(body);


            return StatusCode(200);

        }

        /// <summary>
        /// The controller for handling the status setting / retrieval from CHESS
        /// </summary>
        /// 
        /// POST - Setup a schedule for the CHESS assets
        /// GET -  Get the status of assets


        [HttpPost]
        [Produces("application/json")]
        [Consumes("application/json")]
        [Route("/status/{id}")]

        public IActionResult Status([FromRoute] String id, [FromBody] CHESS body, [FromHeader] String Authorization)
        {

            // Update the stored token
            if (Authorization != null)
                authToken = Authorization;

            if (id == null)
            {
                return Json(assets);
            }


            foreach (CHESS chess in assets)
            {

                Console.WriteLine("Looking for CHESS " + chess.id + " matching " + id);

                if (chess.id.Equals(id))
                    if (body != null)
                    {

                        // we need to update !

                        chess.limits = body.status;

                        return Json(chess);

                    }

            }
            return StatusCode(404);
        }

        // Get the status for a CHESS

        [HttpGet]
        [Produces("application/json")]
        [Consumes("application/json")]
        [Route("/status/{id}")]
        public IActionResult Status([FromRoute] String id, [FromHeader] String Authorization)
        {

            // Update the stored token
            if (Authorization != null)
                authToken = Authorization;

            if (id == null)
            {
                return Json(assets);
            }


            foreach (CHESS chess in assets)
            {

                Console.WriteLine("Looking for CHESS " + chess.id + " matching " + id);

                if (chess.id.Equals(id))

                    return Json(chess);

            }


            return StatusCode(404);

        }
        /// <summary>
        /// Bulk update of Charging Station information
        /// </summary>
        /// <remarks>Receives an array of Charging Station updates (0..*) from the CSMS.   Each Charging Station object may include its overall status, a list of EVSEs, and their meter measurements. </remarks>
        /// <param name="body"></param>
        /// <response code="200">Successfully processed the updates. Returns a list of load curves (one per Charging Station).</response>
        /// <response code="400">Bad request</response>
        /// <response code="401">Unauthorized</response>
        /// <response code="500">Internal server error</response>
        [HttpPost]
        [Route("/update")]
        [Produces("application/json")]
        [Consumes("application/json")]
        [ValidateModelState]
        [SwaggerOperation("CsUpdatePost")]
        [SwaggerResponse(statusCode: 200, type: typeof(List<LoadCurve>), description: "Successfully processed the updates. Returns a list of load curves (one per Charging Station).")]
        public virtual IActionResult CsUpdatePost([FromBody] List<ChargingStationUpdate> body, [FromHeader] String Authorization)
        {


            if (body == null) return BadRequest();

            if (Authorization == null)
                return StatusCode(401);

            // Need to use token to authorize the access
            Token token = decodeToken(Authorization);

            if (!token.scope.Contains("saFlexibilityProvider"))
                return StatusCode(403);

            // check if it already exists !


            foreach (ChargingStationUpdate update in body)
            {
                String id = update.Id;
                String status = update.Status.ToString();

                // Todo: Update the main CHESS status
                CHESS asset = assets.Find(x => x.id == id);
                if (asset != null)
                    asset.currentStatus = status;
                else
                {
                    string adapterid = System.Net.Dns.GetHostName().Replace("-0", "");
                    // create new asset entry for this adapter - same as the init operation
                    asset = new CHESS();
                    asset.id = id;
                    asset.identifier = adapterid;
                    asset.currentStatus = status;
                    assets.Add(asset);
                    try
                    {
                        IoT.Services.Chess chess = new IoT.Services.Chess();
                        chess.Id = id;
                        chess.identifier = adapterid;
                        chess.standard = "REST";
                        chess.location = "CHESS node 2";
                        chess.version = "1.0";
                        Console.WriteLine("CHESS id " + "it-tle-" + id + " adapter " + adapterid);
                        IoT.Services.Chess newtwin = Program.dtClient.CreateOrReplaceDigitalTwin("it-tle-" + chess.Id, chess);

                        AccessPermissionRule accessPermissionRule = new AccessPermissionRule();
                        accessPermissionRule.Id = "it-tle-" + chess.Id + "AccessControlPermissions";

                        Program.dtClient.CreateOrReplaceDigitalTwin("it-tle-" + chess.Id + "AccessControlPermissions", accessPermissionRule);

                        var relationship = new BasicRelationship
                        {
                            TargetId = newtwin.Id,
                            Name = "contains"
                        };
                        string relId = $"{adapterid}-contains->{newtwin.Id}";
                        Program.dtClient.CreateOrReplaceRelationship(adapterid, relId, relationship);
                        Console.WriteLine("Created contains relationship successfully");



                        AccessPermissionRuleTargetSubjectAttributesRelationship rel = new AccessPermissionRuleTargetSubjectAttributesRelationship
                        {
                            TargetId = "saFlexibilityProvidercLtJVPhoOIhL33bZPIMoo9ShquYa",
                            Name = "targetSubjectAttributes"
                        };
                        relId = $"{newtwin.Id}AccessControlPermissions->saFlexibilityProvidercLtJVPhoOIhL33bZPIMoo9ShquYa";
                        Program.dtClient.CreateOrReplaceRelationship(chess.Id + "AccessControlPermissions", relId, rel);

                        String[] additionalSAs = Program.subjectAttributes.Split(' ');

                        foreach (String sa in additionalSAs)
                        {
                            rel = new AccessPermissionRuleTargetSubjectAttributesRelationship
                            {
                                TargetId = sa,
                                Name = "targetSubjectAttributes"
                            };
                            relId = $"{newtwin.Id}AccessControlPermissions->{sa}";
                            Program.dtClient.CreateOrReplaceRelationship("it-tle-" + chess.Id + "AccessControlPermissions", relId, rel);
                            Console.WriteLine("Created permission relationship successfully - " + sa);
                        }
                        // create the telemetry submodel

                        IoT.Services.Submodel submodel = new IoT.Services.Submodel
                        {
                            Id = "it-tle-" + newtwin.Id + "telemetry",

                            SemanticIdValue = "",

                        };
                        submodel.Kind = new Kind { };
                        submodel.Administration = new LangStringElementType();
                        submodel.DataSpecificationTemplateGlobalRefValue = "";
                        submodel.DisplayName = new LangStringElementType();
                        submodel.Description = new LangStringElementType();
                        submodel.Tags = new LangStringElementType();

                        Console.WriteLine(JsonConvert.SerializeObject(submodel));

                        Program.dtClient.CreateOrReplaceDigitalTwin("it-tle-" + chess.Id + "telemetry", submodel);

                        accessPermissionRule = new AccessPermissionRule
                        {
                            Id = newtwin.Id + "telemetryAccessControlPermissions"
                        };

                        Program.dtClient.CreateOrReplaceDigitalTwin(chess.Id + "telemetryAccessControlPermissions", accessPermissionRule);



                        rel = new AccessPermissionRuleTargetSubjectAttributesRelationship
                        {
                            TargetId = "saFlexibilityProvidercLtJVPhoOIhL33bZPIMoo9ShquYa",
                            Name = "targetSubjectAttributes"
                        };
                        relId = $"{newtwin.Id}telemetryAccessControlPermissions->saFlexibilityProvidercLtJVPhoOIhL33bZPIMoo9ShquYa";
                        Program.dtClient.CreateOrReplaceRelationship(chess.Id + "telemetryAccessControlPermissions", relId, rel);
                        Console.WriteLine("Created permission relationship successfully");

                        foreach (String sa in additionalSAs)
                        {
                            rel = new AccessPermissionRuleTargetSubjectAttributesRelationship
                            {
                                TargetId = sa,
                                Name = "targetSubjectAttributes"
                            };
                            relId = $"{newtwin.Id}telemetryAccessControlPermissions->{sa}";
                            Program.dtClient.CreateOrReplaceRelationship(chess.Id + "telemetryAccessControlPermissions", relId, rel);
                            Console.WriteLine("Created permission relationship successfully " + sa);
                        }

                        foreach (EVSEUpdate eVSEUpdate in update.Evse)
                        {
                            IoT.Services.SubmodelElement submodelElement = new IoT.Services.SubmodelElement();

                            submodelElement.Id = "sme-" + "it-tle-" + update.Id + "-" + eVSEUpdate.Id + "measurement";
                            submodelElement.Kind = new Kind { };
                            submodelElement.DataSpecificationTemplateGlobalRefValue = "";
                            submodelElement.DisplayName = new LangStringElementType();
                            submodelElement.Description = new LangStringElementType();
                            submodelElement.Tags = new LangStringElementType();
                            submodelElement.SemanticIdValue = "Measurement";

                            Console.WriteLine(JsonConvert.SerializeObject(submodelElement));

                            Program.dtClient.CreateOrReplaceDigitalTwin("sme-" + "it-tle-" + update.Id + "-" + eVSEUpdate.Id + "measurement", submodelElement);

                            var smerel = new SubmodelElementDataSpecificationRelationship
                            {
                                TargetId = "sme-" + "it-tle-" + update.Id + "-" + eVSEUpdate.Id + "measurement",
                                Name = "submodelElement"

                            };

                            relId = $"{newtwin.Id}telemetry-contains->{eVSEUpdate.Id}measurement";
                            Program.dtClient.CreateOrReplaceRelationship(newtwin.Id + "telemetry", relId, smerel);
                            Console.WriteLine("Created contains relationship successfully");
                        }
                    }
                    catch (RequestFailedException e)
                    {
                        Console.WriteLine($"Create DT error: {e.Status}: {e.Message}");

                    }

                }

                String query = "SELECT DT.$dtId FROM  DigitalTwins twin JOIN DT RELATED twin.contains WHERE twin.$dtId = '" + id + "' and  DT.$metadata.$model = 'dtmi:com:flexchess:chessstatus;1'";
                try
                {

                    Pageable<BasicDigitalTwin> twinResponse = Program.dtClient.Query<BasicDigitalTwin>(query);

                    Console.WriteLine("Got status for " + id);


                    // Update the CHESS status digital twin !
                    foreach (EVSEUpdate eVSEUpdate in update.Evse)
                    {
                        Console.WriteLine("Updating " + "it-tle-" + update.Id + "-" + eVSEUpdate.Id);
                        Boolean registered = false;
                        int count = 0;
                        asset.status = new ChessStatus[update.Evse.Count];
                        if (twinResponse != null)
                            foreach (BasicDigitalTwin twinId in twinResponse)
                            {

                                IoT.Services.ChessStatus twin = Program.dtClient.GetDigitalTwin<IoT.Services.ChessStatus>(twinId.Id);
                         

                                if (twin.Id.Equals("it-tle-" + update.Id + "-" + eVSEUpdate.Id))
                                {
                                    Console.WriteLine("Got matching twin " + twin.Id);
                                    registered = true;

                                    if (!eVSEUpdate.Status.ToString().Equals(twin.status))
                                    {

                                        asset.status[count].Id = "it-tle-" + update.Id+"-"+eVSEUpdate.Id;
                                        asset.status[count].status = eVSEUpdate.Status.ToString();
                                        asset.status[count].recurrence = "continuous";

                                        Console.WriteLine("Creating DT " + eVSEUpdate.Id);

                                        Program.dtClient.CreateOrReplaceDigitalTwin(asset.status[count].Id, asset.status[count].status);
                                        count++;
                                    }

                                }
                            }

                        // Now update the meter readings for this CHESS !
                        Console.WriteLine("Measurments # " + eVSEUpdate.ElectricMeter.Count);
                        foreach (Measurement measurement in eVSEUpdate.ElectricMeter)
                        {

                            // Update the measurement digital twin 
                            try
                            {

                                Console.WriteLine("Adding measurement " + measurement.timestamp);

                                if (measurement.timestamp != null)
                                    Program.dtClient.CreateOrReplaceDigitalTwin("it-tle-"+update.Id+"-"+eVSEUpdate.Id + "measurement", measurement);
                            }
                            catch (Exception ex) { Console.WriteLine("Error adding measurement " + ex.ToString()); }

                        }

                        if (!registered)
                        {

                            Console.WriteLine("Creating EV DT " + "it-tle-" + update.Id + "-" + eVSEUpdate.Id);
                            asset.status[count] = new ChessStatus();
                            asset.status[count].Id = "it-tle-" + update.Id + "-" + eVSEUpdate.Id;
                            if (eVSEUpdate.Status != null)
                                asset.status[count].status = eVSEUpdate.Status.ToString();
                            else
                                asset.status[count].status = "unknown";
                            asset.status[count].capacity = "0";
                            asset.status[count].starttime = "00:00";
                            asset.status[count].endtime = "23:59";
                            asset.status[count].recurrence = "continuous";
                            asset.status[count].service = "all";

                            Program.dtClient.CreateOrReplaceDigitalTwin(asset.status[count].Id, asset.status[count]);


                            var relationship = new BasicRelationship
                            {
                                TargetId = "it-tle-" + update.Id + "-" + eVSEUpdate.Id,
                                Name = "contains"
                            };
                            string relId = $"{update.Id}->{asset.status[count].Id}";
                            Response<BasicRelationship> response = Program.dtClient.CreateOrReplaceRelationship<BasicRelationship>("it-tle-" + update.Id, relId, relationship);
                            if (response != null) Console.WriteLine("Response - " + response.Value);


                            count++;


                            // The measurement relationship is needed if not present

                            relationship = new BasicRelationship
                            {
                                TargetId = "it-tle-" + update.Id + "-" + eVSEUpdate.Id + "measurement",
                                Name = "contains"
                            };
                            relId = $"{eVSEUpdate.Id}->{eVSEUpdate.Id}measurement";
                            response = Program.dtClient.CreateOrReplaceRelationship<BasicRelationship>("it-tle-" + update.Id + "-" + eVSEUpdate.Id, relId, relationship);
                            if (response != null) Console.WriteLine("Response - " + response.Value);

                        }







                    }
                }
                catch (Exception ex)
                {
                    return StatusCode(500);
                }




            }

            TimeSpan interval = new TimeSpan(0, 15, 0);


           
            List<LoadCurve> lcs = new List<LoadCurve>();
            //Todo: get load curve (control status) from the status cache

            foreach (CHESS asset in assets)
            {

                LoadCurve lc = new LoadCurve();

                lc.Csid = asset.id;
                lcs.Add(lc);
                
                List<EvseLimit> evseLimits = new List<EvseLimit>();
                lc.EvseLimit = evseLimits;
  
                //lc.StationLimit = 100;
               
  
                if (asset.limits != null)
                    for (int i = 0; i<asset.limits.Length; i++)
                    {
                    
                        EvseLimit evseLimit = new EvseLimit();
                        List<LoadPoint> loadPoints = new List<LoadPoint>();
                        evseLimit.Limit = loadPoints;
                        evseLimits.Add(evseLimit);

                        ChessStatus status = asset.limits[i];
                        evseLimit.Evseid = (i+1).ToString();
                        Console.WriteLine("Limit " + i);
                        if (asset.limits[i] != null && getStatus(status) && status.status.ToLower().Contains("curtail"))
                        {

                                  // See if there is a curtailment within this interval period

                            DateTime start = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, Int32.Parse(status.starttime.Substring(0, 2)), Int32.Parse(status.starttime.Substring(3, 2)), 0);
                            DateTime end = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, Int32.Parse(status.endtime.Substring(0, 2)), Int32.Parse(status.endtime.Substring(3, 2)), 0);

                            Console.WriteLine("Checking time for Curtailing " + start + " " + end);

                            Console.WriteLine("Time now " + DateTime.Now);

                            //if (DateTime.Now - start < interval)
                            {

                                LoadPoint loadPoint = new LoadPoint();

                                float period = (float)end.Subtract(start).TotalMinutes / 60;
                                float limit = float.Parse(status.capacity) / (400 * (float)Math.Sqrt(3));

                                // compute the limit in amps
                                loadPoint.Current = limit / period;

                                loadPoint.Timestamp = start.ToString("yyyy-MM-ddTHH:mm:ssZ");
                                loadPoints.Add(loadPoint);
                                
                            }

                            //if (DateTime.Now - end <= interval)
                            {

                                LoadPoint loadPoint = new LoadPoint();

                                // remove the limit by setting to max current

                                string max = "32";

                                loadPoint.Current = float.Parse(max);

                                loadPoint.Timestamp = end.ToString("yyyy-MM-ddTHH:mm:ssZ");
                                loadPoints.Add(loadPoint);
                            }

                        }
                    }

            }


            return Json(lcs);
        }
    }
}
