/*
 * EMS adapter - for managing local CHESS virtual battery assets
 *               estimates the current status and predicts most suitable changes to meet a goal / requirement
 *
 * tim@toshiba-bril.com
 * 
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;
using Swashbuckle.AspNetCore.Annotations;
using Swashbuckle.AspNetCore.SwaggerGen;
using Newtonsoft.Json;
using System.ComponentModel.DataAnnotations;
using IO.Swagger.Attributes;
using IO.Swagger.Security;
using Microsoft.AspNetCore.Authorization;
using IO.Swagger.Models;
using Newtonsoft.Json.Linq;
using System.Net;
using System.Threading.Tasks;
using Azure.DigitalTwins.Core;
using Azure;
using IoT.Services;
using Microsoft.Extensions.Logging;
using Microsoft.VisualBasic;
using System.ComponentModel;
using System.Text.Json.Serialization;
using System.Reflection;
using System.Runtime.Serialization.DataContracts;
using System.Net;
using System.Net.NetworkInformation;
using System.Globalization;
using System.IO;
using System.Text;


namespace IO.Swagger.Controllers
{
    /// <summary>
    /// API server for the EMS helper CHESS adapter
    /// </summary>
    [ApiController]
    public class DefaultApiController : Controller
    {



        protected static List<CHESS> assets;

        protected static String authToken = "";
        private readonly ILogger<DefaultApiController> _logger;

        // The main CHESS data structure
        public class CHESS
        {

            public String identifier { get; set; }
            public String location { get; set; }
            public String id { get; set; }
            public String currentStatus { get; set; }
            public ChessStatus[] status { get; set; }
            public ChessStatus[] limits { get; set; }


        }


        public class Token
        {
            public String sub { get; set; }
            public String aut { get; set; }
            public String aud { get; set; }
            public String nbf { get; set; }
            public String azp { get; set; }
            public String scope { get; set; }
            public String iss { get; set; }
            public String exp { get; set; }
            public String iat { get; set; }
            public String jti { get; set; }
            public String location { get; set; }
            public String uri { get; set; }

            public Token() { }
        }


        // DT Data
        public class DTData
        {

            public String Id {get; set;}
            public String DataType {get; set;}
            public String LevelType {get; set;}
            public String ValueFormat {get; set;}
            public String Symbol {get; set;}
            public String Unit {get; set;}
            public Double Value {get; set;}

        }

        public class DTString
        {

            public String Id {get; set;}
            public String DataType {get; set;}
            public String LevelType {get; set;}
            public String ValueFormat {get; set;}
            public String Symbol {get; set;}
            public String Unit {get; set;}
            public String Value {get; set;}

        }


        public DefaultApiController(ILogger<DefaultApiController> logger)
        {
            _logger = logger;
            if (assets == null)
                assets = new List<CHESS>();
        }


        protected Double dtLookup(DTData[] dtData, String id)
        {

            foreach (DTData data in dtData)
            if (data.Id.EndsWith(id)) return data.Value;

            return 0;
        }
        
        // check for the activation of a chess status
        private Boolean getStatus(ChessStatus status)
        {
            DateTime starttime;
            DateTime endtime;

            if (status.recurrence.ToLower().Equals("daily") ||
                (status.recurrence.ToLower().Equals("weekdays") && ((DateTime.Today.DayOfWeek != DayOfWeek.Saturday) && (DateTime.Today.DayOfWeek != DayOfWeek.Sunday))) ||
                (status.recurrence.ToLower().Equals("weekends") && ((DateTime.Today.DayOfWeek == DayOfWeek.Saturday) || (DateTime.Today.DayOfWeek == DayOfWeek.Sunday))))
            {

                return true;


            }

            return false;
        }

        //Function to decode JWT token
        private Token decodeToken(String token)
        {
            String str = token.Substring(token.IndexOf(".") + 1, token.LastIndexOf(".") - token.IndexOf(".") - 1);
            if (str.Length % 4 != 0)
                str += new String('=', 4 - str.Length % 4);

            byte[] data = Convert.FromBase64String(str);
            string decodedString = System.Text.Encoding.UTF8.GetString(data);
            Token jwt = JsonConvert.DeserializeObject<Token>(decodedString);


            return jwt;
        }

        //Get the subject attributes for a twin from the ADT model
        private String getSubjectAttribute(IoT.Services.Chess twin)
        {
            String query = "SELECT DT.$dtId FROM DIGITALTWINS twin JOIN DT RELATED twin.targetSubjectAttributes WHERE twin.$dtId = '" + twin.Id + "AccessControlPermissions'";

            // get the permissions from subject attriubtes for the submodel
            Pageable<BasicDigitalTwin> attributeResponse = Program.dtClient.Query<BasicDigitalTwin>(query);
            String subjectAttribute = "";
            if (attributeResponse != null)
            {

                foreach (BasicDigitalTwin attribute in attributeResponse)
                {
                    subjectAttribute += " " + attribute.Id;
                }


            }
            else subjectAttribute = "default";
            return subjectAttribute;
        }

        /// <summary>
        /// The controller for handling the initialisation of CHESS adapter
        /// </summary>
        /// 
        /// POST - Setup CHESS assets with this adapter

        [HttpPost]
        [Consumes("application/json")]
        [Produces("text/plain")]
        [Route("/init")]
        public IActionResult Init([Required][FromBody] CHESS body, [FromHeader] String Authorization)
        {

            if (body == null)
            {
                return Json(assets);
            }

            // store the token for later use to call APIs
            if (Authorization != null)
                authToken = Authorization;

            Console.WriteLine("Body " + Newtonsoft.Json.JsonConvert.SerializeObject(body));

            assets.Add(body);


            return StatusCode(200);

        }

        /// <summary>
        /// The controller for handling the status setting / retrieval from CHESS
        /// </summary>
        /// 
        /// POST - Setup a schedule for the CHESS assets
        /// GET -  Get the status of assets


        [HttpPost]
        [Produces("application/json")]
        [Consumes("application/json")]
        [Route("/status/{id}")]
        public IActionResult Status([FromRoute] String id, [FromBody] CHESS body, [FromHeader] String Authorization)
        {

            // Update the stored token
            if (Authorization != null)
                authToken = Authorization;

            if (id == null)
            {
                return Json(assets);
            }

       
            if (body == null) return BadRequest();

            if (Authorization == null)
                return StatusCode(401);
    
         
            foreach (CHESS chess in assets)
            {

                Console.WriteLine("Looking for CHESS " + chess.id + " matching " + id);

                if (chess.id.Equals(id))
                    if (body != null)
                    {

                        // we need to update !

                        chess.limits = body.status;
                   
                        break;

                    }

            }

     
            List<CHESS> res = new List<CHESS>();

 
            // now get latest status values from AAS server

            string result = Get("http://aasserver.default.svc/status", authToken);

            CHESS[] currentStates = JsonConvert.DeserializeObject<CHESS[]>(result);

            // go through the status required
            foreach (ChessStatus status in body.status)
            {       


                
                try {
                    Int32 startHour = Int32.Parse(status.starttime.Substring(0, 2));
                    Int32 startMinute = Int32.Parse(status.starttime.Substring(3, 2));
                    Int32 endHour = Int32.Parse(status.endtime.Substring(0, 2));
                    Int32 endMinute = Int32.Parse(status.endtime.Substring(3, 2));  
                    Double targetCapacity = Double.Parse(status.capacity);
                    TimeSpan start = new TimeSpan(startHour, startMinute, 0); 
                    TimeSpan end = new TimeSpan(endHour, endMinute, 0);
                    
                    // See the current flexibility provision matching this requirement
                    foreach (CHESS currentState in currentStates)
                    {
                        Console.WriteLine("CHESS status " + currentState.id);   
                        if (body == null || body.location == null || currentState.location == null || currentState.location.ToLower().Equals(body.location.ToLower()))                    
                        foreach (ChessStatus currentStatus in currentState.status)
                        {
                            if (currentStatus.recurrence.ToLower().Contains("daily") || currentStatus.recurrence.Equals(status.recurrence))
                            {
                                if (status.status == null || status.status.ToLower().Contains(currentStatus.status.ToLower()))
                                if (status.service == null || status.service.Equals("all") || status.service.ToLower().Equals(currentStatus.service.ToLower()))
                                {
                                    startHour = Int32.Parse(currentStatus.starttime.Substring(0, 2));
                                    startMinute = Int32.Parse(currentStatus.starttime.Substring(3, 2));
                                    endHour = Int32.Parse(currentStatus.endtime.Substring(0, 2));
                                    endMinute = Int32.Parse(currentStatus.endtime.Substring(3, 2));  
                                    
                                    Double capacity = Double.Parse(currentStatus.capacity);
                                    TimeSpan thisStart = new TimeSpan(startHour, startMinute, 0); 
                                    TimeSpan thisEnd = new TimeSpan(endHour, endMinute, 0);

                                    TimeSpan period = thisEnd-thisStart;
                                    TimeSpan overlap = new TimeSpan(0,0,0);
                                    Double capacityStart = 0;
                                    Double capacityEnd = 0;
                                    if ((start - thisStart).TotalMinutes >= 0)
                                    {
                                       Console.WriteLine("Overlap is " + (start - thisStart).TotalMinutes);
                                       capacityStart = (Double) ((start-thisStart).TotalMinutes) * capacity / period.TotalMinutes;
                                       capacityEnd = (Double) ((end-thisStart).TotalMinutes) * capacity / period.TotalMinutes;
                                    }
                                    if (capacityStart > capacity) capacityStart = capacity;
                                    if (capacityEnd > capacity) capacityEnd = capacity;
                       

                                    Console.WriteLine("Capacity at start is " + capacityStart+ " of total " + capacity);
                                    Console.WriteLine("Capacity at end is " + capacityEnd+ " of total " + capacity);
                                    currentStatus.capacityStart = capacityStart;
                                    currentStatus.capacityEnd = capacityEnd;
                                }
                            }

                        }
                        
                    }
              
                    // Now see what capacity is needed
                    if (targetCapacity > 0)
                    {


                            Console.WriteLine("Capacity needed for " + status.starttime + "->" + status.endtime + " " + status.status  + " is " + targetCapacity);

                            foreach (CHESS currentState in currentStates)
                            {
                                Console.WriteLine("CHESS status " + currentState.id);   
                                if (body == null || body.location == null || currentState.location == null || currentState.location.ToLower().Equals(body.location.ToLower()))                    
                                foreach (ChessStatus currentStatus in currentState.status)
                                {
                                    if (currentStatus.recurrence.ToLower().Contains("daily") || currentStatus.recurrence.Equals(status.recurrence))
                                    {
                                        Console.WriteLine("Checking " + currentState.id);
                                        if (status.status == null ||status.status.ToLower().Contains(currentStatus.status.ToLower()))
                                        if (status.service == null || status.service.Equals("all") || status.service.ToLower().Equals(currentStatus.service.ToLower()))
                                        {

                                            if (status.status.ToLower().Contains("force"))
                                            {

                                                String url = "http://aasserver.default.svc/api/v3.0/submodels/" + currentState.id + "EnergyEntity/submodel-elements/$value";

                                                Console.WriteLine("Getting energy entity from DT - " + url);
                                                result = Get(url, authToken);
                                                Console.WriteLine("Got " + result);
                                        
                                                DTData[] dtData = JsonConvert.DeserializeObject<DTData[]>(result);
                                                Double maxEnergy = 0;
                                                Double maxPower = 0;
                                                Double efficiency = 1;
                                                Double power80 = 0;
                                                Double minSoC = 0;

                                                if (dtData != null && dtData.Length > 0)
                                                {
                                                    maxEnergy = dtLookup(dtData, "maximumAllowedBatteryEnergy");      
                                                    efficiency = dtLookup(dtData, "energyRoundtripEfficiency") / 100;
                                                } else
                                                    Console.WriteLine("Cannot get energy data from DT");


                                                url = "http://aasserver.default.svc/api/v3.0/submodels/" + currentState.id + "PowerEntity/submodel-elements/$value";

                                                Console.WriteLine("Getting power entity from DT - " + url);
                                                result = Get(url, authToken);
                                                Console.WriteLine("Got " + result);
                                        
                                                dtData = JsonConvert.DeserializeObject<DTData[]>(result);
                                              
                                                if (dtData != null && dtData.Length > 0)
                                                {
                                                    maxPower = dtLookup(dtData, "maximumAllowedBatteryPower");      
                                                    power80 = dtLookup(dtData, "powerCapabilityAt80Charge");
                                                    if (power80 == null || power80 == 0) power80 = maxPower;

                                                } else
                                                    Console.WriteLine("Cannot get power data from DT");

                                                url = "http://aasserver.default.svc/api/v3.0/submodels/" + currentState.id + "StateOfBatteryEntity/submodel-elements/$value";

                                                Console.WriteLine("Getting SoC entity from DT - " + url);
                                                result = Get(url, authToken);
                                                Console.WriteLine("Got " + result);
                                        
                                                dtData = JsonConvert.DeserializeObject<DTData[]>(result);
                                                
                                                if (dtData != null && dtData.Length > 0)
                                                {
                                                    minSoC = dtLookup(dtData, "minSoC");      
                                                

                                                } else
                                                    Console.WriteLine("Cannot get SoC data from DT");

                                                Double thisCapacity = currentStatus.capacityEnd; 

                                                // see if we are energy capacity or power limited 
                                                if (maxEnergy * efficiency > thisCapacity)
                                                {
                                                    Console.WriteLine("Can increase this capacity " + currentState.id);
                                                    currentStatus.efficiency = efficiency;
                                               
                                                    Double availableCapacity = maxEnergy * (1-minSoC/100) * efficiency - thisCapacity;
                                                    Double energyLimit = efficiency * power80 * (end-start).TotalMinutes / 60;    
                                                    if (availableCapacity > energyLimit) 
                                                    {
                                                        Console.WriteLine("Available capacity greater than limit "  + energyLimit);
                                                        currentStatus.capacityMax = energyLimit;
                                                        targetCapacity -= (energyLimit - thisCapacity);
                                                        currentStatus.probability =  thisCapacity/(energyLimit+thisCapacity);
    
                                                    } else
                                                    {
                                                        Console.WriteLine("Available capacity less than limit "  + energyLimit);
                                                        currentStatus.probability =  thisCapacity / (thisCapacity+availableCapacity);
                                                        currentStatus.capacityMax = thisCapacity + availableCapacity;
                                                        targetCapacity -= availableCapacity;
                                                    }
                                                    if (res.IndexOf(currentState) < 0)
                                                        res.Add(currentState);
                                                }

                                            }
                                        }
                                    }
                                }
                               
                            }
                            // now calculate the priority levels based on the probability of being in the state
                            Int32[] ranks = new Int32[res.Count];
                            for (int i=0; i<res.Count; i++)
                            {
                                Double maxProb = 0;
                                Int32 maxIndex = 0;
                                foreach (CHESS resState in res)
                                {
                                    Double totalProb = 0;
                                    Int32 probCount = 1;
                                    foreach (ChessStatus resStatus in resState.status)
                                    {
                                        if (resStatus.probability > 0)
                                        {
                                            totalProb += resStatus.probability;
                                            probCount ++;
                                        }
                                    }

                                    // rank based on probability order
                                    if (totalProb/probCount > maxProb)
                                    {
                                        int j=0;
                                        for (j=0; j<i; j++)
                                        {
                                            if (ranks[j] ==  res.IndexOf(resState))
                                             break;
                                        }
                                        if (j<i)
                                        {
                                            maxIndex = res.IndexOf(resState);
                                            maxProb = totalProb/probCount;
                                        }
                                    }

                                }
                                ranks[i] = maxIndex;
                                Console.WriteLine("Rank " + i + " is "  + maxProb);
                            }
                            Int32 count = 0;
                            Int32 level = 0;
                            // now assign the priority levels
                            for (int i=0; i<res.Count; i++)
                            {
                                foreach (ChessStatus resStatus in res[ranks[i]].status)
                                {
                                    resStatus.priority = level;
                                }
                                count++; 
                                if (count >= res.Count/4)
                                {
                                    count = 0;
                                    level++;
                                }
                            

                            }



                    }
                    

                } catch (Exception ex)
                {
                    Console.WriteLine("Error " + ex.ToString());
                }      
            }
    
           
            return Json(res);
        }

        

        // Get the status for a CHESS

        [HttpGet]
        [Produces("application/json")]
        [Consumes("application/json")]
        [Route("/status/{id}")]
        public IActionResult Status([FromRoute] String id, [FromHeader] String Authorization)
        {

            // Update the stored token
            if (Authorization != null)
                authToken = Authorization;

            if (id == null)
            {
                return Json(assets);
            }


            foreach (CHESS chess in assets)
            {

                Console.WriteLine("Looking for CHESS " + chess.id + " matching " + id);

                if (chess.id.Equals(id))

                    return Json(chess);

            }


            return StatusCode(404);

        }


        // Get -  remote HTTP request
        protected string Get(string uri, string token)
        {
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(uri);
            request.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;
            if (token != null)
                request.Headers.Add("Authorization", token);
    
            using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
            using (Stream stream = response.GetResponseStream())
            using (StreamReader reader = new StreamReader(stream))
            {
                return reader.ReadToEnd();
            }
        }

        // Post -  remote HTTP request
        protected string Post(string uri, string json, string token)
        {
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(uri);
            //request.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;
            request.Timeout = 120000;

            var data = Encoding.ASCII.GetBytes(json);

            request.Method = "POST";
            request.ContentType = "application/json";
            request.PreAuthenticate = true;
            if (token != null)
                request.Headers.Add("Authorization", token);
            request.Accept = "application/json";
            using (var stream = request.GetRequestStream())
            {
                stream.Write(data, 0, data.Length);
            }

            var response = (HttpWebResponse)request.GetResponse();

            var responseString = new StreamReader(response.GetResponseStream()).ReadToEnd();

            return responseString;
        }



        // Estimate cycle cost using empirical degradation model
        protected Double cycleCost(Double SocMax, Double SocMin, String batteryType)
        {
            Console.WriteLine("Soc max " + SocMax + " Soc min " + SocMin + " type " + batteryType);
            Double res = 0;

            Double[] N1  = {10000,9000,8000,7000,6000,5000,4000,3000,2000,1000};     // This is the degradation model which we will estimate
            Double[] N2  = {10000,9500,9000,8500,8000,7500,7000,6500,6000,5500};     // This is the degradation model which we will estimate
            Double[] N3  = {10000,9750,9500,9250,9000,8750,8500,8250,8000,7750};     // This is the degradation model which we will estimate
            
            int i = (int)( (SocMax - SocMin) * 10 );
        
            if (batteryType.ToLower().Equals("li-ion"))  
                res = (9460/28.2) / (2 * N1[i] * (SocMax - SocMin));
            else if (batteryType.ToLower().Equals("lfp"))
                res = (11460/28.2) / (2 * N2[i] * (SocMax - SocMin));
            else if (batteryType.ToLower().Equals("lto"))
                res = (21460/28.2) / (2 * N3[i] * (SocMax - SocMin));
            return res;
        }
  

        /// <summary>
        /// Get the current flexibility provision for the specified target
        /// </summary>
        /// <remarks>  </remarks>
        /// <param name="body"></param>
        /// <response code="200">Successfully processed the updates</response>
        /// <response code="400">Bad request</response>
        /// <response code="401">Unauthorized</response>
        /// <response code="500">Internal server error</response>
        [HttpPost]
        [Route("/current")]
        [Produces("application/json")]
        [Consumes("application/json")]
        [ValidateModelState]
        [SwaggerOperation("currentPost")]
        [SwaggerResponse(statusCode: 200, type: typeof(List<CHESS>), description: "Successfully got the curent flexibility profiles for given target profile")]
        public virtual IActionResult currentPost([FromBody]CHESS body, [FromHeader] String Authorization)
        {

            // Update the stored token
            if (Authorization != null)
                authToken = Authorization;

            if (body == null) return BadRequest();

            if (Authorization == null)
                return StatusCode(401);
    
  
            List<CHESS> res = new List<CHESS>();

 
            // now get latest status values from AAS server

            string result = Get("http://aasserver.default.svc/status", authToken);

            CHESS[] currentStates = JsonConvert.DeserializeObject<CHESS[]>(result);

            foreach (ChessStatus status in body.status)
            {       


                
                try {
                    Int32 startHour = Int32.Parse(status.starttime.Substring(0, 2));
                    Int32 startMinute = Int32.Parse(status.starttime.Substring(3, 2));
                    Int32 endHour = Int32.Parse(status.endtime.Substring(0, 2));
                    Int32 endMinute = Int32.Parse(status.endtime.Substring(3, 2));  
                    Double targetCapacity = Double.Parse(status.capacity);
                    TimeSpan start = new TimeSpan(startHour, startMinute, 0); 
                    TimeSpan end = new TimeSpan(endHour, endMinute, 0);
                    
                    // See the current flexibility provision matching this requirement
                    foreach (CHESS currentState in currentStates)
                    {
                        Console.WriteLine("CHESS status " + currentState.id);   
                        if (body == null || body.location == null || currentState.location == null || currentState.location.ToLower().Equals(body.location.ToLower()))                    
                        foreach (ChessStatus currentStatus in currentState.status)
                        {
                            if (currentStatus.recurrence.ToLower().Contains("daily") || currentStatus.recurrence.Equals(status.recurrence))
                            {
                                if (status.status == null || status.status.ToLower().Contains(currentStatus.status.ToLower()))
                                if (status.service == null || status.service.Equals("all") || status.service.ToLower().Equals(currentStatus.service.ToLower()))
                                {
                                    startHour = Int32.Parse(currentStatus.starttime.Substring(0, 2));
                                    startMinute = Int32.Parse(currentStatus.starttime.Substring(3, 2));
                                    endHour = Int32.Parse(currentStatus.endtime.Substring(0, 2));
                                    endMinute = Int32.Parse(currentStatus.endtime.Substring(3, 2));  
                                    
                                    Double capacity = Double.Parse(currentStatus.capacity);
                                    TimeSpan thisStart = new TimeSpan(startHour, startMinute, 0); 
                                    TimeSpan thisEnd = new TimeSpan(endHour, endMinute, 0);

                                    TimeSpan period = thisEnd-thisStart;
                                    TimeSpan overlap = new TimeSpan(0,0,0);
                                    Double capacityStart = 0;
                                    Double capacityEnd = 0;
                                    if ((start - thisStart).TotalMinutes >= 0)
                                    {
                                       Console.WriteLine("Overlap is " + (start - thisStart).TotalMinutes);
                                       capacityStart = (Double) ((start-thisStart).TotalMinutes) * capacity / period.TotalMinutes;
                                       capacityEnd = (Double) ((end-thisStart).TotalMinutes) * capacity / period.TotalMinutes;
                                    }
                                    if (capacityStart > capacity) capacityStart = capacity;
                                    if (capacityEnd > capacity) capacityEnd = capacity;
                       

                                    Console.WriteLine("Capacity at start is " + capacityStart+ " of total " + capacity);
                                    Console.WriteLine("Capacity at end is " + capacityEnd+ " of total " + capacity);
                                    currentStatus.capacityStart = capacityStart;
                                    currentStatus.capacityEnd = capacityEnd;
                                }
                            }

                        }
                        
                    }
              
                    // Now see what capacity is needed
                    if (targetCapacity > 0)
                    {


                            Console.WriteLine("Capacity needed for " + status.starttime + "->" + status.endtime + " " + status.status  + " is " + targetCapacity);

                            foreach (CHESS currentState in currentStates)
                            {
                                Console.WriteLine("CHESS status " + currentState.id);   
                                if (body == null || body.location == null || currentState.location == null || currentState.location.ToLower().Equals(body.location.ToLower()))                    
                                foreach (ChessStatus currentStatus in currentState.status)
                                {
                                    if (currentStatus.recurrence.ToLower().Contains("daily") || currentStatus.recurrence.Equals(status.recurrence))
                                    {
                                        Console.WriteLine("Checking " + currentState.id);
                                        if (status.status == null ||status.status.ToLower().Contains(currentStatus.status.ToLower()))
                                        if (status.service == null || status.service.Equals("all") || status.service.ToLower().Equals(currentStatus.service.ToLower()))
                                        {

                                            if (status.status.ToLower().Contains("force"))
                                            {

                                                String url = "http://aasserver.default.svc/api/v3.0/submodels/" + currentState.id + "EnergyEntity/submodel-elements/$value";

                                                Console.WriteLine("Getting energy entity from DT - " + url);
                                                result = Get(url, authToken);
                                                Console.WriteLine("Got " + result);
                                        
                                                DTData[] dtData = JsonConvert.DeserializeObject<DTData[]>(result);
                                                Double maxEnergy = 0;
                                                Double maxPower = 0;
                                                Double efficiency = 1;
                                                Double power80 = 0;
                                                Double minSoC = 0;
                                                String batteryType = "";

                                                if (dtData != null && dtData.Length > 0)
                                                {
                                                    maxEnergy = dtLookup(dtData, "maximumAllowedBatteryEnergy");      
                                                    efficiency = dtLookup(dtData, "energyRoundtripEfficiency") / 100;
                                                } else
                                                    Console.WriteLine("Cannot get energy data from DT");


                                                url = "http://aasserver.default.svc/api/v3.0/submodels/" + currentState.id + "PowerEntity/submodel-elements/$value";

                                                Console.WriteLine("Getting power entity from DT - " + url);
                                                result = Get(url, authToken);
                                                Console.WriteLine("Got " + result);
                                        
                                                dtData = JsonConvert.DeserializeObject<DTData[]>(result);
                                              
                                                if (dtData != null && dtData.Length > 0)
                                                {
                                                    maxPower = dtLookup(dtData, "maximumAllowedBatteryPower");      
                                                    power80 = dtLookup(dtData, "powerCapabilityAt80Charge");
                                                    if (power80 == null || power80 == 0) power80 = maxPower;

                                                } else
                                                    Console.WriteLine("Cannot get power data from DT");


                                                url = "http://aasserver.default.svc/api/v3.0/submodels/" + currentState.id + "StateOfBatteryEntity/submodel-elements/$value";

                                                Console.WriteLine("Getting state of battery entity from DT - " + url);
                                                result = Get(url, authToken);
                                                Console.WriteLine("Got " + result);
                                        
                                                dtData = JsonConvert.DeserializeObject<DTData[]>(result);
                                                
                                                if (dtData != null && dtData.Length > 0)
                                                {
                                                    minSoC = dtLookup(dtData, "minSoC");      
                                                

                                                } else
                                                    Console.WriteLine("Cannot get battery state data from DT");


                                                url = "http://aasserver.default.svc/api/v3.0/submodels/" + currentState.id + "IdentificationEntity/submodel-elements/$value";

                                                Console.WriteLine("Getting identification entity from DT - " + url);
                                                result = Get(url, authToken);
                                                Console.WriteLine("Got " + result);
                                        
                                                DTString[] dtString = JsonConvert.DeserializeObject<DTString[]>(result);
                                                
                                                if (dtString != null && dtString.Length > 0)
                                                {

                                                    foreach (DTString data in dtString)
                                                        if (data.Id.EndsWith("batteryType")) batteryType = data.Value;
                                                        
                                                

                                                } else
                                                    Console.WriteLine("Cannot get identification data from DT");

                                                Double thisCapacity = currentStatus.capacityEnd; 
                                                currentStatus.cycleCost =  cycleCost( thisCapacity/maxEnergy, currentStatus.capacityStart/maxEnergy, batteryType );

                                                // see if we are energy capacity or power limited 
                                                if (maxEnergy * efficiency > thisCapacity)
                                                {
                                                    Console.WriteLine("Can increase this capacity " + currentState.id);
                                                    currentStatus.efficiency = efficiency;
                                               
                                                    Double availableCapacity = maxEnergy * (1-minSoC/100) * efficiency - thisCapacity;
                                                    Double energyLimit = efficiency * power80 * (end-start).TotalMinutes / 60;    
                                                    if (availableCapacity > energyLimit) 
                                                    {
                                                        Console.WriteLine("Available capacity greater than limit "  + energyLimit);
                                                        currentStatus.capacityMax = energyLimit;
                                                        targetCapacity -= (energyLimit - thisCapacity);
                                                        currentStatus.probability =  thisCapacity/(energyLimit+thisCapacity);
    
                                                    } else
                                                    {
                                                        Console.WriteLine("Available capacity less than limit "  + energyLimit);
                                                        currentStatus.probability =  thisCapacity / (thisCapacity+availableCapacity);
                                                        currentStatus.capacityMax = thisCapacity + availableCapacity;
                                                        targetCapacity -= availableCapacity;
                                                    }
                                                    if (res.IndexOf(currentState) < 0)
                                                        res.Add(currentState);
                                                }

                                            }
                                        }
                                    }
                                }
                               
                            }
                            // now calculate the priority levels based on the probability of being in the state
                            Int32[] ranks = new Int32[res.Count];
                            for (int i=0; i<res.Count; i++)
                            {
                                Double maxProb = 0;
                                Int32 maxIndex = 0;
                                foreach (CHESS resState in res)
                                {
                                    Double totalProb = 0;
                                    Int32 probCount = 1;
                                    foreach (ChessStatus resStatus in resState.status)
                                    {
                                        if (resStatus.probability > 0)
                                        {
                                            totalProb += resStatus.probability;
                                            probCount ++;
                                        }
                                    }

                                    // rank based on probability order
                                    if (totalProb/probCount > maxProb)
                                    {
                                        int j=0;
                                        for (j=0; j<i; j++)
                                        {
                                            if (ranks[j] ==  res.IndexOf(resState))
                                             break;
                                        }
                                        if (j<i)
                                        {
                                            maxIndex = res.IndexOf(resState);
                                            maxProb = totalProb/probCount;
                                        }
                                    }

                                }
                                ranks[i] = maxIndex;
                                Console.WriteLine("Rank " + i + " is "  + maxProb);
                            }
                            Int32 count = 0;
                            Int32 level = 0;
                            // now assign the priority levels
                            for (int i=0; i<res.Count; i++)
                            {
                                foreach (ChessStatus resStatus in res[ranks[i]].status)
                                {
                                    resStatus.priority = level;
                                }
                                count++; 
                                if (count >= res.Count/4)
                                {
                                    count = 0;
                                    level++;
                                }
                            

                            }



                    }
                    

                } catch (Exception ex)
                {
                    Console.WriteLine("Error " + ex.ToString());
                }      
     
                      
            }
            
            res.Add(body);

            return Json(res);


        }

        /// <summary>
        /// Get the current flexibility provision for the specified target
        /// </summary>
        /// <remarks>  </remarks>
        /// <response code="200">Successfully processed the updates</response>
        /// <response code="400">Bad request</response>
        /// <response code="401">Unauthorized</response>
        /// <response code="500">Internal server error</response>
        [HttpGet]
        [Route("/current")]
        [Produces("application/json")]
        [ValidateModelState]
        [SwaggerOperation("currentGet")]
        [SwaggerResponse(statusCode: 200, type: typeof(List<CHESS>), description: "Successfully got the current available flexibility profiles")]
        public virtual IActionResult currentGet([FromQuery] String location, [FromQuery] String recurrence, [FromQuery] String service, [FromHeader] String Authorization)
        {

            // Update the stored token
            if (Authorization != null)
                authToken = Authorization;


            if (Authorization == null)
                return StatusCode(401);
    
  
            List<CHESS> res = new List<CHESS>();

 
            // now get latest status values from AAS server

            string result = Get("http://aasserver.default.svc/status", authToken);

            CHESS[] currentStates = JsonConvert.DeserializeObject<CHESS[]>(result);

                    
            // See the current flexibility provision 
            foreach (CHESS currentState in currentStates)
            {
                if ((currentState.currentStatus == null || currentState.currentStatus.Equals("available")) && (location == null || currentState.location == null || location.ToLower().Equals(currentState.location.ToLower())))
                {

                    foreach (ChessStatus currentStatus in currentState.status)
                    {
                            if (recurrence == null || recurrence.ToLower().Equals(currentStatus.recurrence.ToLower()))
                            if (service == null || service.ToLower().Equals("all") || service.ToLower().Equals(currentStatus.service.ToLower()))
                                
                                res.Add(currentState);
                            

                    }
                }

            }
          
     
            return Json(res);


        }
    }
}
